# 연산자 중복

<details>
<summary>1. 연산자 중복의 개념</summary>
<div markdown="1">       

### 연산자 중복이란?
* 피연산자에 따라 서로 다른 연산을 하도록 동일한 연산자를 중복해서 만드는 것이 연산자 중복(operator overloading)임

### 두개의 정수 더하기
>int a=2, b=3, c;
>
>c = a + b;  // + 결과는 5, 정수가 피연산자일 때 숫자 더하기

### 두 개의 문자열 합치기
* +연산자는 문자열을 연결하는 표현으로 사용할 수 있음
* 실제 <string> 헤더 파일에는 string 클래스와 함께 문자열을 연결하는 + 연산자가 구현되어 있음
  >string a= “C”, c;
  >
  >c = a + “++”;  //문자열이 피연산자일 때 두 개의 문자열 합치기, c = “C++”

### 두 색을 섞은 새로운 색 만들기
* +연산자로 두 색을 혼합하여 새로운 색을 만드는 것을 표현할 수 있음
  >Color a(BLUE), b(RED), c;
  >
  >c = a + b;  //c = VIOLET. a, b의 두 색을 섞은 새로운 Color 객체  c

### 두 개의 배열 더하기
>SortedArray a(2,5,9), b(3,7,10), c;  //a의 원소는 2,5,9, b의 원소는 3,7,10
>
>c = a + b;  //c = {2,3,5,6,7,10}. 정렬된 두 배열을 결합한(merge) 새로운 배열 생성

### 연산자 중복의 장점
* 코드를 직관적으로 표현할 수 있게 함으로써, 프로그램의 가독성을 높여주는 긍정적인 기능을 함

</div>
</details>

___

<details>
<summary>2. 연산자 중복의 특징</summary>
<div markdown="1">       

* **C++ 언어에 본래 있는 연산자만 중복 가능하다**
  * %%, ## 등 새로운 연산자를 만들어 낼 수는 없음
    
* **연산자 중복은 피연산자의 타입이 다른 연산을 새로 정의하는 것이다**
  * C++에서 기본 + 연산자의 피연산자는 모두 숫자임
  * So, + 연산자를 새로 중복하려면 ‘객체+수’, ‘수+객체’, ‘객체+객체’와 같이 정수나 실수가 아닌 객체나 값을 더하는 + 연산이어야 함
    
* **연산자 중복은 함수를 통해 이루어진다**
  * 연산자 중복이란 새로운 연산 처리를 수행하는 함수를 구현하는 것
  * 이 함수를 **연산자 함수(operator function)** 라고 부름
    
* **연산자 중복은 반드시 클래스와 관계를 가진다**
  * 중복된 연산자는 반드시 피연산자에 객체를 동반함
  * So, 연산자 함수는
    * 클래스의 멤버 함수로 구현하든지,
    * 전역 함수로 구현하고 클래스에 프렌드 함수로 선언함
* **연산자 중복으로 피연산자의 개수를 바꿀 수 없다**
* **연산자 중복으로 연산의 우선순위를 바꿀 수 없다**
* **모든 연산자가 중복 가능한 것은 아니다**
</div>
</details>

___

<details>
<summary>3. 연산자 함수 선언과 연산자 함수 개요</summary>
<div markdown="1">       

#### 연산자 함수 작성 2가지 방법
* 클래스의 **멤버 함수**로 구현
* **외부 함수**로 구현하고 클래스의 **프렌드 함수로 선언**
  
#### 연산자 함수 선언 방법
>리턴타입 operator 연산자(매개변수리스트);

* 이름이 `'operator'` 키워드와 `연산자`로 구성된다는 점 외에는 보통 함수 선언과 동일함
  
#### 외부 함수로 구현하고 클래스에 프렌드 함수로 선언하는 경우
```C++
Color operator + (Color op1, Color op2); //외부 전역 함수
bool operator == (Color op1, Color op2); //외부 전역 함수
...
class Color {
...
  friend Color operator + (Color op1, Color op2); //프렌드 선언
  friend bool operator == (Color op1, Color op2); //프렌드 선언
};
```
* +연산자와 == 연산자 함수는 외부 전역 함수로 작성하고,
* 두 개의 피연산자를 모두 매개 변수에 전달함
  
#### 클래스의 멤버 함수로 선언되는 경우
```C++
class Color {
  ...
  Color operator + (Color op2);  //왼쪽 피연산자는 객체 자신이고 오른쪽 피연산자가 op2에 전달
  bool operator == (Color op2);  //왼쪽 피연산자는 객체 자신이고 오른쪽 피연산자가 op2에 전달
};
```
* +나 ==의 오른쪽 피연산자만 매개 변수 op2에 전달되고,
* 왼쪽 피연산자는 객체 자신이므로 매개 변수에 전달되지 않음
* 클래스의 멤버로 구현되었든 외부 함수로 구현되었든, + 나 == 연산자는 다음과 같이 사용됨
```C++
Color a(BLUE), b(RED), c;
c = a + b;  //Color operator + (Color op2)나
            //Color operator + (Color op1, Color op2) 중 구현된 것을 호출함
if(a == b) { //bool operator == (Color op2)나
  ...        //bool operator == (Color op1, Color op2) 중 구현된 것을 호출함
}
```

</div>
</details>
